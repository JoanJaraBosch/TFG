{% extends 'core/base.html' %}
{% load i18n %}
{% get_current_language as LANGUAGE_CODE %}
{% block title %}{% trans "Monitorització" %}{% endblock %}

{% block background %}{% load static %}{% static 'core/img/monitor-bg.jpg' %}{% endblock %}
{% block headers %}
<script src="https://canvasjs.com/assets/script/canvasjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.min.js" integrity="sha512-s+xg36jbIujB2S2VKfpGmlC3T5V2TF3lY48DX7u2r9XzGzgPsa6wTpOQA7J9iffvdeBN0q9tKzRxVxw1JviZPg==" crossorigin="anonymous"></script>
<style>

h3 {
  text-align: center;
}

/* graf 2 por barba */
* {
  box-sizing: border-box;
}

.column {
  float: left;
  width: 50%;
  padding: 5px;
}

/* Clearfix (clear floats) */
.row::after {
  content: "";
  clear: both;
  display: table;
}

/*slider */
.slidecontainer {
  width: 100%;
}

.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 25px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider:hover {
  opacity: 1;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  background: #4CAF50;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 25px;
  height: 25px;
  background: #4CAF50;
  cursor: pointer;
}
</style>
<h1>URV-Odroid</h1>
{% endblock %}
{% block content %}
<form>
<select id ="ips" name="select">
<option value="master">master</option>
</select>
<input id="clickMe" type="button" value="Monitoritzar" onclick="monitor_odroid();"/>
</form>
<input id="continueMe" type="button" value="ContinueMonitoritzar" onclick="continueGraf();"/>
<input id="pauseMe" type="button" value="PauseMonitoritzar" onclick="pause();"/>
<input id="stopMe" type="button" value="StopMonitoritzar" onclick="stop();"/>
<div class="slidecontainer">
  <p>{%trans "Nombre de punts pels grafics lineals:" %}<span id="value-contador-output"></span></p>
  <input id="value-contador" type="range" min="10" max="100" value="10">
</div>
<div class="slidecontainer">
  <p>{%trans "Delay en segons per la obtenció de dades:" %}<span id="value-temps-output"></span></p>
  <input id="value-temps" type="range" min="1" max="60" value="2">
</div>
</br></br>
<h3 aling="justify" id="uptime">Uptime: ---</h3>
<div id="monitor"></div>
<div class="row">
<div  class="column">
<canvas id="chartContainer" style="height: 500px; width:100%;"></canvas>
</div>
<div  class="column">
<canvas id="chartContainerMem" style="height: 500px; width:100%;"></canvas>
</div>
</div>
<div  class="row">
<div  class="column">
<canvas id="chartContainerMemAvail" style="height: 500px; width:100%;"></canvas>
</div>
<div  class="column">
<canvas id="chartContainerTemp" style="height: 500px; width:100%;"></canvas>
</div>
</div>
<div  class="row">
<div  class="column">
<canvas id="chartContainerMemIO" style="height: 500px; width:100%;"></canvas>
</div>
<div  class="column">
<canvas id="chartContainerLoad" style="height: 500px; width:100%;"></canvas>
</div>
</div>
<div  class="row">
<div  class="column">
<canvas id="chartContainerEntropy" style="height: 500px; width:100%;"></canvas>
</div>
<div  class="column">
<canvas id="chartContainerBandwidth" style="height: 500px; width:100%;"></canvas>
</div>
</div>
</div>
<script>
const reader = new FileReader();

var stopGraf = 0;
var whoami = 1;
var net = 1;
var reset = 0;
var count = 0;

var chartLoad;
var chartNET;
var chartCPU;
var chartEntropy;
var chartMEM;
var chartMEMAvail;
var chartTemp;
var chartMemIO;

var dataLength = 10;
var temps = 2;

var network;
var timer_json;
var cpu_usage;
var mem;
var mem_avail;
var mem_io;
var temp;
var up_time;
var load;
var entropy;
var interficies = [];
var net_info = [];
var net_info_2 = [];
var select;
var ip_private = "{{ IP_PRIVATE }}";
var ws = new WebSocket("wss://"+ip_private+":3000");
var started = 1;

function start_memio_chart(){
   var ctx = document.getElementById("chartContainerMemIO");
   chartMemIO = new Chart(ctx, {
        type: "line",
        data: {
                labels: [],
                datasets: [{
			fill: false,
			 backgroundColor: [
                                'rgba(257,168,0,1)',
                                'rgba(257,168,0,1)',
                                'rgba(257,168,0,1)',
                                'rgba(257,168,0,1)',
                                'rgba(257,168,0,1)',
                                'rgba(257,168,0,1)',
                               	'rgba(257,168,0,1)',
                                'rgba(257,168,0,1)',
                                'rgba(257,168,0,1)',
                                'rgba(257,168,0,1)',
                        ],
			borderColor: [
				'rgba(257,168,0,1)',
			],
			label: "Input", 
			data: []
		},
		{
			fill: false,
			borderColor: [
                                'rgba(164,169,173,1)',
                        ],
			backgroundColor: [
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                                'rgba(164,169,173,1)',
                        ],
			label: "Output", 
			data: []
		}],
        },
        options: {
                responsive: true,
                title: {
                        display: true,
                        text: 'Monitoring Memory I/O'
                },
                scales: {
                        xAxes: [{
                                ticks: {
                                        display: true,
                                        beginAtZero: true,
                                },
                                 scaleLabel: {
                                        display: true,
                                        labelString: 'Updates'
                                }
                        }],
                        yAxes: [{
                                ticks: {
                                        display: true,
                                        beginAtZero: true,
                                },
                                 scaleLabel: {
                                        display: true,
                                        labelString: 'kB_read/kB_write'
                                }

                        }]
                }
        }
});
};

function updateChartMemIO(contador, dataLength){
	if(chartMemIO.data.datasets[0].data.length==dataLength){
         for(var j = 0; j<dataLength-1; j++){
                chartMemIO.data.datasets[0].data[j] = chartMemIO.data.datasets[0].data[j+1];
                chartMemIO.data.datasets[1].data[j] = chartMemIO.data.datasets[1].data[j+1];
		chartMemIO.data.labels[j] = chartMemIO.data.labels[j+1];
         }

         chartMemIO.data.datasets[0].data[chartMemIO.data.datasets[0].data.length-1] = parseFloat(mem_io[0]);
         chartMemIO.data.datasets[1].data[chartMemIO.data.datasets[1].data.length-1] = parseFloat(mem_io[1]);
         chartMemIO.data.labels[chartMemIO.data.datasets[0].data.length-1] = contador;
     }else{
         chartMemIO.data.datasets[0].data[contador] = parseFloat(mem_io[0]);
         chartMemIO.data.datasets[1].data[contador] = parseFloat(mem_io[1]);
	 chartMemIO.data.labels[contador] = contador;
     }
     chartMemIO.update();
};

function start_network_chart(noms){
var ctx_net = document.getElementById("chartContainerBandwidth");
var init_graf = [];
var colors = ['rgba(35, 31, 32, 1)', 'rgba(172, 22, 44, 1)' ,'rgba(255, 206, 0, 1)' ,'rgba(164, 169, 173, 1)' ,'rgba(235, 0, 40, 1)' ,'rgba(219, 217, 214, 1)'];

for(var z=0; z < noms.length; z++){
	init_graf.push({label: noms[z], data: [], fill: false, borderColor: [colors[z]]});	
} 

chartNET = new Chart(ctx_net, {
        type: "line",
        data: {
		labels: [],
		datasets: init_graf,
        },
        options: {
                responsive: true,
                title: {
                        display: true,
                        text: 'Monitoring Bandwith'
                },
                scales: {
                        xAxes: [{
				ticks: {
					display: true,
					beginAtZero: true,
                                },
				 scaleLabel: {
                                        display: true,
                                        labelString: 'Updates'
                                }
                        }],
                        yAxes: [{
                                ticks: {
                                        display: true,
                                        beginAtZero: true,
                                },
                                 scaleLabel: {
                                        display: true,
                                        labelString: 'Bytes/s'
                                }

                        }]
                }
        }
});

};

function updateCartNet(contador, dataLength) {
     for(var t=0; t < chartNET.data.datasets.length; t++){
        if(chartNET.data.datasets[t].data.length==dataLength){
                for(var j = 0; j<dataLength-1; j++){
                        chartNET.data.datasets[t].data[j] = chartNET.data.datasets[t].data[j+1];
                }
                chartNET.data.datasets[t].data[chartNET.data.datasets[t].data.length-1] = parseFloat(net_info_2[t])-parseFloat(net_info[t]);
        }else{
                chartNET.data.datasets[t].data[contador] = parseFloat(net_info_2[t])-parseFloat(net_info[t]);
                chartNET.data.labels[contador] = contador;
        }
        net_info[t]=net_info_2[t];
     }

     if(chartNET.data.labels.length==dataLength){
        for(var j = 0; j<dataLength-1; j++){
                chartNET.data.labels[j] = chartNET.data.labels[j+1];
        }
        chartNET.data.labels[dataLength-1] = contador;
     }

     chartNET.update();
};


function start_cpu_chart(){
var ctx = document.getElementById("chartContainer");
chartCPU = new Chart(ctx, {
        type: "line",
	data: {
        	labels: [],
        	datasets: [{
   			backgroundColor: [
 				'rgba(35,31,32,1)',
				'rgba(35,31,32,1)',
				'rgba(35,31,32,1)',
				'rgba(35,31,32,1)',
				'rgba(35,31,32,1)',
				'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
			],
            		label: 'CPU USAGE',
            		data: [],

		}],
	},
        options: {
                responsive: true,
        	title: {
            		display: true,
           		text: 'Monitoring CPU'
        	},
                scales: {
 			xAxes: [{
               			 scaleLabel: {
                                        display: true,
                                        labelString: 'Updates'
                                }
            		}],
                        yAxes: [{
                                ticks: {
					display: true,
                                        beginAtZero: true,
                                },
				 scaleLabel: {
                                        display: true,
                                        labelString: '% cpu'
                                }

                        }]
                }
        }
});

};

function updateChartCpu(contador, dataLength) {
     if(chartCPU.data.datasets[0].data.length==dataLength){
         for(var j = 0; j<dataLength-1; j++){
		chartCPU.data.datasets[0].data[j] = chartCPU.data.datasets[0].data[j+1];
		chartCPU.data.labels[j] = chartCPU.data.labels[j+1];
	 }
        
    	 chartCPU.data.datasets[0].data[chartCPU.data.datasets[0].data.length-1] = parseFloat(cpu_usage);     
     	 chartCPU.data.labels[chartCPU.data.datasets[0].data.length-1] = contador;
     }else{
         chartCPU.data.datasets[0].data[contador] = parseFloat(cpu_usage);
         chartCPU.data.labels[contador] = contador;
     }
     chartCPU.update();
};

function start_entropy_chart(){
var ctx_entropy = document.getElementById("chartContainerEntropy");
chartEntropy = new Chart(ctx_entropy, {
        type: "line",
        data: {
                labels: [],
                datasets: [{
			backgroundColor: [
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                        ],

                        label: 'System Entropy',
                        data: [],

                }],
        },
        options: {
                responsive: true,
                title: {
                        display: true,
                        text: 'Monitoring Entropy'
                },
                scales: {
                        xAxes: [{
                                 scaleLabel: {
                                        display: true,
                                        labelString: 'Updates'
                                }
                        }],
                        yAxes: [{
                                ticks: {
                                        display: true,
                                        beginAtZero: true,
                                },
                                 scaleLabel: {
                                        display: true,
                                        labelString: 'Random numbers available'
                                }

                        }]
                }
        }
});

};

function updateChartEntropy(contador, dataLengthEntropy) {
     if(chartEntropy.data.datasets[0].data.length==dataLengthEntropy){
         for(var j = 0; j<dataLengthEntropy-1; j++){
                chartEntropy.data.datasets[0].data[j] = chartEntropy.data.datasets[0].data[j+1];
                chartEntropy.data.labels[j] = chartEntropy.data.labels[j+1];
         }

         chartEntropy.data.datasets[0].data[chartEntropy.data.datasets[0].data.length-1] = parseFloat(entropy);
         chartEntropy.data.labels[chartEntropy.data.datasets[0].data.length-1] = contador;
     }else{
         chartEntropy.data.datasets[0].data[contador] = parseFloat(entropy);
         chartEntropy.data.labels[contador] = contador;
     }

     chartEntropy.update();
};

function start_mem_avail_chart(){

var ctx_mem_avail = document.getElementById("chartContainerMemAvail");
chartMEMAvail = new Chart(ctx_mem_avail, {
        type: "doughnut",
        data: {
                labels: ['Used', 'Available'],
                datasets: [{
                        data: [],
			backgroundColor: [
                        	'rgba(255, 206, 0,1)',
                        	'rgba(219, 217, 214, 1)',
                	],
                }],
        },
        options: {
                responsive: true,
		title: {
                        display: true,
                        text: 'Monitoring disk available'
                },
        }
}); 

};

function updateChartDisk() {
     try{
         chartMEMAvail.data.datasets[0].data[0]= parseFloat(mem_avail[0]);
         chartMEMAvail.data.datasets[0].data[1]= parseFloat(mem_avail[1]);
         chartMEMAvail.update();
     }catch(err){
   
     }
};


function start_temp_chart(){
var ctx_temp = document.getElementById("chartContainerTemp");
chartTemp = new Chart(ctx_temp, {
        type: "doughnut",
        data: {
                labels: ['Current temperature', 'Critic temperature'],
                datasets: [{
                        data: [],
                        backgroundColor: [
                               'rgba(172,22, 44, 1)',
		 	       'rgba(219, 217, 214, 1)',
                        ],
                }],
        },
        options: {
                responsive: true,
                title: {
                        display: true,
                        text: 'Monitoring Temperature'
                },
        }
});
};

function updateChartTemp() {
     try{
         chartTemp.data.datasets[0].data[0]= parseFloat(temp[0]);
         chartTemp.data.datasets[0].data[1]= parseFloat(temp[1]) -parseFloat(temp[0]);
         chartTemp.update();
     }catch(err){

     }
};

function start_mem_chart(){
var contador_mem = 0;
var ctx_mem = document.getElementById("chartContainerMem");
chartMEM = new Chart(ctx_mem, {
        type: "line",
        data: {
                labels: [],
                datasets: [{
			backgroundColor: [
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                                'rgba(35,31,32,1)',
                        ],
                        label: 'MEM RAM USAGE',
                        data: [],
                }],
        },
        options: {
                responsive: true,
		title: {
			display: true,
			text: 'Monitoring RAM'
		},
                scales: {
			xAxes: [{
				scaleLabel: {
                                        display: true,
	                                labelString: 'Updates'
                                }
			}],
                        yAxes: [{
                                ticks: {
                                        beginAtZero: true
                                },
				scaleLabel: {
					display: true,
					labelString: 'Free MB RAM'
				}
                        }]
                }
        }
});

};

function updateChartRam(contador_mem ,dataLength_mem) {
      if(chartMEM.data.labels.length<dataLength_mem){
         chartMEM.data.datasets[0].data[contador_mem] = parseFloat(mem);
         chartMEM.data.labels[contador_mem] = contador_mem;
      }else{

              for(var i =0; i<dataLength_mem-1 ;i++){
                chartMEM.data.datasets[0].data[i] = chartMEM.data.datasets[0].data[i+1];
                chartMEM.data.labels[i] = chartMEM.data.labels[i+1];
              }
              chartMEM.data.datasets[0].data[chartMEM.data.datasets[0].data.length-1] = parseFloat(mem);
              chartMEM.data.labels[chartMEM.data.datasets[0].data.length-1]=contador_mem;
     }
     chartMEM.update();
};

function updateUptime(valor) {
	var h3 = document.getElementById("uptime");
	if(valor==1){
	        h3.innerHTML="Uptime: "+up_time[0]+"days "+up_time[1]+"h "+up_time[2]+"min";
	}else{
		h3.innerHTML="Uptime: ---";
	}
}

function start_load_chart(){
var ctx_load = document.getElementById("chartContainerLoad");
chartLoad = new Chart(ctx_load, {
        type: "bar",
        data: {
                labels: ['1 min', '5 min', '15 min', '1 min critic', '5 min critic', '15 min critic'],
                datasets: [{
                        data: [0, 0, 0, 0, 0, 0,],
                        backgroundColor: [
                               'rgba(247, 168, 0, 1)',
                               'rgba(164, 169, 173, 1)',
                               'rgba(35, 31, 32, 1)',
			       'rgba(255, 206, 0, 1)',
                               'rgba(219, 217, 214, 1)',
                               'rgba(172, 22, 44, 1)',
                        ],
                }],
        },
        options: {
                responsive: true,
                title: {
                        display: true,
                        text: 'Monitoring System Load'
                },
                scales: {
                        xAxes: [{
                                scaleLabel: {
                                        display: true,
                                        labelString: 'Load'
                                }
                        }],
                        yAxes: [{
                                ticks: {
                                        beginAtZero: true
                                 },
                                scaleLabel: {
                                        display: true,
                                        labelString: ''
                                }
                        }]
                },
		legend: {
                	display: false
         	},
        }
});

};

function updateChartLoad() {
      for(var i = 0; i<load.length+load.length-2; i++){
	if(i<load.length-1){
        	chartLoad.data.datasets[0].data[i] = parseFloat(load[i]);
        }
	else{
		chartLoad.data.datasets[0].data[i] = parseFloat(load[load.length-1]-load[i-load.length+1]);
	}
      }
      chartLoad.update();
};


function getting_ips(){
 var ips = {{ ips|safe }};
 var capa = document.getElementById("ips");
 var paso;
 console.log("s'executa la funcio");
 for (paso = 0; paso < ips.length-1; paso++) {
   console.log("entra al bucle");
   var option = document.createElement("option");
   var aux = ips[paso].split(",");
   option.value = aux[1];
   option.innerHTML = aux[1];
   capa.appendChild(option);
 };
};

function monitor_odroid(){
 if(started == 0){
   stop();
   contador = 0;
   chartLoad.clear();
   chartNET.clear();
   chartCPU.clear();
   chartEntropy.clear();
   chartMEM.clear();
   chartMEMAvail.clear();
   chartTemp.clear();
   chartMemIO.clear();

   chartLoad.destroy();
   chartNET.destroy();
   chartCPU.destroy();
   chartEntropy.destroy();
   chartMEM.destroy();
   chartMEMAvail.destroy();
   chartTemp.destroy();
   chartMemIO.destroy(); 
   
   chartLoad="";
   chartNET="";
   chartCPU="";
   chartEntropy="";
   chartMEM="";
   chartMEMAvail="";
   chartTemp="";
   chartMemIO="";
   
   console.log("Faig reseteig");
   ws = "";
   ws = new WebSocket("wss://"+ip_private+":3000");
   select = document.getElementById("ips").value;
   ws.onopen = function() {
      console.log('connected');
      start_cpu_chart();
      start_mem_chart();
      start_mem_avail_chart();
      start_temp_chart();
      start_load_chart();
      start_entropy_chart();
      start_memio_chart();
      ws.send(select);
      ws.send("monitor-"+temps);
   };

   ws.onmessage = function(e) {
    if(stopGraf==0){
        console.log('json resposta: '+e.data);
        reader.readAsText(e.data);
        jsonGLobal();
    }
   };  
 }else{
   started = 0;
   try{
     select = document.getElementById("ips").value;
     console.log(ws);
    }catch(error){
     console.log("falta el dnsmasq, o no estava el fitxer quan tocava, fes el simbolic link a odroid/ips");
 
     ws.onerror = function(evt) {
        alert("Hi ha un error amb el servidor node la placa master. Iniceu-lo o reinicieu-lo amb pm2 start/restart servidor.js");
     };
    };
     start(select);
   };
};

var cpu_boolean = 0;

function jsonGLobal(){
 console.log("Entro amb linterval");
 ws.send("monitor-"+temps);

 reader.onload = function() {
    console.log(reader.result);
    json_message = JSON.parse(reader.result);
    cpu_usage = json_message.cpu;
    mem_avail = json_message.mem_avail;
    mem_avail = mem_avail.split(" ");
    mem = json_message.mem;
    temp = json_message.temp;
    temp = temp.split(" ");
    up_time = json_message.up;
    up_time = up_time.split("-");
    load = json_message.load;
    load = load.split(" ");
    entropy = json_message.entropy;
    mem_io = json_message.write_read
    mem_io = mem_io.split(" ");
    network = json_message.net;
    network = network.split("_");
    if(net==1){
      for(var i=1; i<network.length;i++){
          interficies.push(network[i].split(" ")[0].replace(":", "").concat("_recieved"));
	  interficies.push(network[i].split(" ")[0].replace(":", "").concat("_send"));
	  net_info.push(network[i].split(" ")[1]);
	  net_info.push(network[i].split(" ")[2]);
      }
      console.log(interficies);
      console.log(net_info);
      net=0;
      start_network_chart(interficies);
     }else {
	net_info_2 = [];
	for(var i=1; i<network.length;i++){
          net_info_2.push(network[i].split(" ")[1]);
	  net_info_2.push(network[i].split(" ")[2]);
	}
     }      
  };

  updateChartRam(count, dataLength);
  updateUptime(1);
  updateChartLoad();
  updateChartEntropy(count, dataLength);
  updateCartNet(count, dataLength);
  updateChartCpu(count, dataLength); 
  updateChartTemp();
  updateChartDisk();
  updateChartMemIO(count, dataLength);
  count = count +1;
};

ws.onopen = function() {
      console.log('connected');
      start_cpu_chart();
      start_mem_chart();
      start_mem_avail_chart();
      start_temp_chart();
      start_load_chart();
      start_entropy_chart();
      start_memio_chart();
};

function pause(){
	stopGraf=1;
};

function continueGraf(){
	stopGraf=0;
        ws.send("monitor-"+temps);
};

ws.onmessage = function(e) {
   if(stopGraf==0){
   	console.log('json resposta: '+e.data);
   	reader.readAsText(e.data);
   	jsonGLobal();
   }
};


function start(select){
	ws.send(select);
	ws.send("monitor-"+temps);
};

function stop(){
  interficies = [];
  net_info = [];
  net_info_2 = [];
  updateUptime(0);
  net=1;  
  ws.close();
  whoami=1;
};

window.onload = getting_ips;

var slider = document.getElementById("value-contador");
var output = document.getElementById("value-contador-output");
output.innerHTML = slider.value; // Display the default slider value

// Update the current slider value (each time you drag the slider handle)
slider.oninput = function() {
  output.innerHTML= this.value;
  dataLength=this.value;
}

var slider2 = document.getElementById("value-temps");
var output2 = document.getElementById("value-temps-output");
output2.innerHTML = slider2.value; // Display the default slider value

// Update the current slider value (each time you drag the slider handle)
slider2.oninput = function() {
  output2.innerHTML= this.value;
  temps=this.value;
}

</script>
{% endblock %}
